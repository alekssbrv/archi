# LogScoper

Написанный CLI (так в народе называются консольные утилиты) -- инструмент, которые читает входящие логи.

Что мы делаем в этой утилите:

* научим ее читать access-логи (поддержим формат NGINX)
* научим ее фильтровать по диапазону времени
* научим ее фильтровать по статус-кодам и по регулярным выражениям
* научим ее считать агрегаты: распределение по HTTP запросам, квантили 95ые и 99ые тайминги ответов
* научим ее строить гистрограммы времени ответа по МС "боксам"

python -m logscoper <команда> [опции]

## Команда stats 

### Что делает: считает статистику по файлу логов.
* total - сколько всего строк/запросов прочитано
* status - словарь с количеством запросов по каждому HTTP-коду (например: {200: 69 , 404: 96, 405: 3}).
* rt_avg_ms - среднее время ответа (в миллисекундах, округлять до 2 знаков). Если нет данных о времени ответа — вывести n/a.
* rt_p95_ms — 95-й перцентиль времени ответа
* rt_p99_ms - 99-й перцинтель времени ответа
* top_paths — список из N самых популярных путей по файлу логов (например: ["/index.html", "/login", "/api"]), вместе с количеством запросов.
### Опции: 
* --path access.log — путь к файлу лога.
* --top 5 — сколько самых популярных URL выводить (по умолчанию 10).
* --since 2025-09-10T12:00:00+00:00 — учитывать только записи после этой даты/времени.
* --until 2025-09-10T13:00:00+00:00 — учитывать только записи до этого момента.
* --status 5xx или --status 200,404 — фильтр по статусам.
* --grep "regex" — фильтр по пути (например, --grep "^/api").
* --json — вывод в формате JSON (иначе — текстом).

## Команда filter

### Что делает: выводит только те строки, которые подходят под условия фильтрации.
### Опции:
* --path access.log — путь к файлу лога.
* --since 2025-09-10T12:00:00+00:00 — учитывать записи начиная с этой даты/времени (включительно).
* --until 2025-09-10T13:00:00+00:00 — учитывать записи до этого момента (не включая).
* --status 5xx или --status 200,404 — фильтр по статусам.
* --grep "regex" — фильтр по пути (регулярное выражение).
* --out filtered.txt — если задано, писать вывод в файл; иначе — в stdout.

## Команда hist

### Что делает: строит гистограмму по времени ответа (request_time). Каждый запрос попадает в “корзину” шириной bucket-ms миллисекунд.
* --path access.log — путь к файлу лога.
* --bucket-ms 200 — ширина корзины (в мс). По умолчанию 100.
* --since, --until, --status, --grep — те же фильтры, что и для stats/filter.
* --json — вывод в формате JSON (иначе — текстом).
* --strict — если в логах нет request_time, вернуть ненулевой код выхода.

## Ограничения
Времена --since/--until задаются в ISO-8601. Если часовой пояс не указан, считать UTC.

### Для stats:
rt_avg_ms и перцентили считаются только по записям, где есть request_time.

Если request_time отсутствует везде, в текстовом выводе показать n/a; в JSON — null.
### Для filter:
Если bytes_sent равно - в исходном логе, выводить None или - (на выбор курса; главное — единообразно). Рекомендуем -.

rt= печатать с исходной точностью (например 0.120 → 0.12 допустимо, но лучше не обрезать значащие нули).
### Для hist:
Корзина [k, k+bucket) (левая граница включительно, правая — нет), кроме последней, которая может быть “хвостовой”.

Ключи корзин в JSON — строки вида "0-200", "200-400" и т. д.


# Architecture


![img.png](img.png)

## Логика архитектуры программы:

### 1. Domain (домен) - предметная область

Здесь все самое чистое. Тут как раз должен поселиться ваш `LogEntry` (как пример), вычисления, фильтры, статистика. **Те что не зависят от других слоев.**

### 2. Use Cases (сценарии)

Сценарии описывают что делает приложение:
* посчитать статистику
* отфильтровать логи
* нарисовать гистограму

### 3. Адаптеры

Тут строится связь между пользователем и вашем приложением и логикой. Как на вход так и на выход. 
К примеру:
* данные, которые попадают на вход
* данные, которые должны вернуться на выход

Здесь должно оказаться все то что превращается в то, что становится понятной предметной области.

### 4. Инфраструктура
Всё, что связано с окружением и запуском приложения.
Консольный интерфейс, точка входа, работа с файлами, стандартным выводом/ошибками.
Этот слой «собирает» всё приложение и связывает остальные слои.

### Пакеты в корне `logscoper`'а:

- commands - сценарии: `stats`, `filter`, `hist`
- models - предметная область: сущности, фильтры, вычисления, статистика.
- adapters - адаптеры: парсинг входных данных, преобразование результатов JSON в текст и обратно
- infra - инфраструктура: CLI, точка входа и т.д.


### Важное (по картинке):
* `models` **НЕ ЗАВИСИТ** от адаптеров, инфраструктуры, библиотек ввода/вывода.
* `commands` зависят только от Domain.
* `adapters` знает только о `models` и `commands` но в `infra` не лезут
* `infra` собирает все классы и только она вызывает соответствующие библиотеки -- `argparse`, `sys`, `pathlib` и тд.
